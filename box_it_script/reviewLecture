function add(num_1, num_2) {
    return num_1 + num_2;
}

// functions can be assigned to variables
const add = (num_1, num_2) => {
    return num_1 + num_2;
}

add(2,5);
add(add(2,5), 7);

//applyFunctionToNumber is a higher order function
//it takes the first parameter of a number
//it takes the second parameter of a callback function
function applyFunctionToNumber(number, fn) {
    return fn(number);
}

//num here has to be same as number above as is the same number of arguments
const result = applyFunctionToNumber(5, (num) => ){
    return num * 2
} )

//lets go over some common higher order functions
//Array has two of them built in

//map higher order function takes in a callback function and 
//returns an Array
//the callback function takes in 3 arguments 
//first one is the current value 
//second is the index of the current value
//third is the entire array being mapped_array

const array = [1,2,3,4,5];
const doubledArray = array.map((value, index, array) => {
    return values *2
}
console.log(doubledArray);

//map method reverse engineered
function map(arr, fn) {
    //arr.forEach((number) => {
      //  fn(number, index, array)
    //})

    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        const node = arr[i];
        newArr.push(fn(value, i, arr));
    }
    return newArr;
}
//above push(fn) number of parameters has to map to the function below
const array = [1,2,3,4,5];
const reverseEngineerMapResult = map(array, (value, index, arr) => {
    console.log(array);
    return values * 2;
})

//reduce higher order function
//takes in a callback function
//the callback function takes in up to 5 parameters
//first parameter is a accumulator
//second paramter is the current value
//third paramter is the current index
//fourth optional parameter is the array
//fifth parameter is the intitial value

const itemCosts = [1,2,3,4,5];
const reducedItemcOSTS = itemCosts.reduce((accumulator, value) => ) {
    return accumulator + value
}, 5);

console.log(reducedItemcOSTS);
console.log(result)